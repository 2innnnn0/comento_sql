# 프로그래머스 과제피드백

1. 모든 레코드 조회하기.
-- 코드를 입력하세요
# 동물 보호소에 들어온 모든 동물의 정보를 ANIMAL_ID순으로 조회하는 SQL문을 작성해주세요
(바구니에서 빨간 사과를 꺼낸다.) 템플릿으로 SQL을 작성해보겠습니다.

# 동물 보호소에 들어온 : FROM ANIMAL_INS
# 모든 동물의 정보를 : SELECT * 
# 조건 X : WHERE 없음.
# ANIMAL_ID순으로 : ORDER BY ANIMAL_ID
# 조회하는 SQL문을 작성해주세요.

SELECT -- 2. 모든 동물의 정보
    ANIMAL_ID, 
    ANIMAL_TYPE,
    DATETIME,
    INTAKE_CONDITION,
    NAME,
    SEX_UPON_INTAKE
FROM ANIMAL_INS -- 1. 어디에서? "동물 보호소 바구니"에서
ORDER BY ANIMAL_ID -- 3. ANIMAL_ID순으로

2. 역순 정렬하기
-- 코드를 입력하세요
SELECT NAME, DATETIME
FROM ANIMAL_INS
ORDER BY ANIMAL_ID DESC

3. 아픈 동물 찾기
-- 코드를 입력하세요
SELECT ANIMAL_ID, NAME
FROM ANIMAL_INS
WHERE INTAKE_CONDITION = 'Sick' -- INTAKE_CONDITION이 Sick 인 경우를 뜻함 ↩

4. 어린 동물 찾기
-- 코드를 입력하세요
SELECT ANIMAL_ID, NAME
FROM ANIMAL_INS 
WHERE INTAKE_CONDITION != 'Aged' -- INTAKE_CONDITION이 Aged가 아닌 경우를 뜻함 ↩
# WHERE INTAKE_CONDITION <> 'Aged' -- INTAKE_CONDITION이 Aged가 아닌 경우를 뜻함 ↩
# 같지 않다. !=, <>

5. 동물의 아이디와 이름
-- 코드를 입력하세요
SELECT ANIMAL_ID, NAME
FROM ANIMAL_INS
ORDER BY ANIMAL_ID

6. 여러 기준으로 정렬하기
-- 코드를 입력하세요
SELECT ANIMAL_ID, NAME, DATETIME
FROM ANIMAL_INS
ORDER BY NAME ASC, DATETIME DESC

7. 상위 n개 레코드
-- 코드를 입력하세요
SELECT NAME
FROM ANIMAL_INS 
ORDER BY DATETIME -- 가장 오래된 순으로 나옴.
LIMIT 1 -- TOP1 (row수 갯수 정하는 명령어)


# GROUP BY 설명 
# 묶는컬럼명은 SELECT와 GROUP_BY 셋트메뉴다.
```sql
SELECT
    {범주형컬럼명}, -- 2. (묶는기준은?) "~별"
    COUNT(집계할값) -- 집계값 (횟수COUNT | 평균AVG | 합계SUM, 최소최대MIN, MAX)
FROM 
    {테이블} -- 1. (어디에서?)
GROUP BY
    {범주형컬럼명} -- 3. (묶는기준은?)
HAVING -- 4. 집계값의 조건
    COUNT(집계할값) > 10 -- (e.g 10개 보다 큰)
```

# *주의* GROUP BY없이 집계는 가능하다.
SELECT
    COUNT() -- 집계값 (횟수COUNT | 평균AVG | 합계SUM)
FROM 
    {테이블} -- 1. (어디에서?)


# 인덱싱Indexing 설명
- 첫번째 컬럼부터 1부터 차례대로 넘버링이 붙어짐.
- 컬럼명이 긴 경우 매번 길게 쓰는 것이 어려우니 
인덱싱으로 GROUP BY, ORDER BY에서만 적용이 가능하다.

SELECT 
    AAAAAAAAAA, -- 1번째 컬럼 (집계 기준)
    BBBBBBBBBB, -- 2번째 컬럼 (집계 기준)
    CCCCCCCCCC, -- 3번째 컬럼 (집계 기준)
    COUNT(id) -- 4번째 컬럼 (집계 계산값) 
GROUP BY -- 인덱싱 
    1,2,3,4 -- 1,2,3번째컬럼을 집계기준으로 사용.
ORDER BY -- 인덱싱
    1 -- 첫번째 컬럼을 기준으로 정렬.


# HAVING
{A}구문
SELECT
    bike_id,
    SUM(distance) AS total_distance
  FROM rental_history
  WHERE DATE(rent_at) BETWEEN DATE('2021-01-01') AND DATE('2021-01-31')
  GROUP BY
    bike_id


1. HAVING 쓴것.
{A}
HAVING SUM(distance) > 50000 -- 기존 한줄


2. HAVING 안쓴것.
-- 서브쿼리SUB-QUERY
SELECT
  bike_id,
  total_distance
FROM 
(
  {A}
)
WHERE total_distance > 50000


# 문제풀기
-- Q. 대여정류소"별" 대여횟수를 구하기.
```sql
SELECT
    rent_station_id, -- 2. 대여정류소별로
    COUNT(rent_at) AS rent_count -- 2. (무엇을?)대여횟수
FROM 
    rental_history -- 1. (어디에서?) 대여 이력에서
GROUP BY 
    rent_station_id -- 3. (묶는기준은?) 대여정류소별로
```

-- Q. 정류소ID:101의 대여횟수 구하기
SELECT
  rent_station_id,
  COUNT(rent_at) as rent_count
FROM rental_history
WHERE rent_station_id = 101
GROUP BY rent_station_id


# SOLVE-SQL GROUP BY 문제 
1. 데이터 그룹으로 묶기
SELECT
  quartet,
  ROUND(AVG(x),2) AS x_mean,
  ROUND(VARIANCE(X),2) AS x_var,
  ROUND(AVG(y),2) AS y_mean,
  ROUND(VARIANCE(Y),2) AS y_var
FROM
  points
GROUP BY
  1
2. 할부는 몇 개월로 해드릴까요
SELECT 
  payment_installments,
  COUNT(DISTINCT order_id) AS order_count, -- 주문 수
  MIN(payment_value) AS min_value, -- 최소 결제 금액
  MAX(payment_value) AS max_value, -- 최대 결제 금액
  AVG(payment_value) AS avg_value -- 평균 결제 금액
FROM olist_order_payments_dataset
WHERE payment_type='credit_card'
GROUP BY 1
ORDER BY 1

3. 레스토랑 웨이터의 팁 분석
SELECT 
  day, -- 요일
  time, -- 시간대
  ROUND(AVG(tip),2) AS avg_tip, -- 평균 팁
  ROUND(AVG(size),2) AS avg_size -- 평균 일행 수
FROM tips
GROUP BY 1,2
ORDER BY 1,2

4. 일별 블로그 방문자 수 집계
SELECT
  event_date_kst AS dt,
  COUNT(DISTINCT user_pseudo_id) AS users
FROM ga
WHERE event_date_kst between '2021-08-02' AND '2021-08-09'
GROUP BY 1
ORDER BY 1

5. 우리 플랫폼에 정착한 판매자 1
SELECT 
  seller_id,
  COUNT(distinct order_id) as orders
FROM olist_order_items_dataset
GROUP BY 1
HAVING count(distinct order_id) >= 100

6. 최고의 근무일을 찾아라
SELECT
  day,
  SUM(tip) AS tip_daily
FROM tips
GROUP BY 1
ORDER BY 2 DESC
LIMIT 1

7. 버뮤다 삼각지대에 들어가버린 택배
SELECT 
  DATE(order_delivered_carrier_date) AS order_delivered_carrier_date,
  COUNT(distinct order_id) AS orders
FROM olist_orders_dataset
WHERE order_delivered_carrier_date IS NOT null
AND order_delivered_customer_date IS NULL
AND DATE(order_delivered_carrier_date) BETWEEN '2017-01-01' AND '2017-01-31'
GROUP BY 1
ORDER BY 1


# 코드컨벤션convention(약속, 규율)
-- 코드습관을 잘 들이시면 가독성이 좋은 코드를 쓸 수 있습니다.
-- "명령어" 대문자, 소문자 막 섞어써도 작동은 되지만.
  -- "명령어"는 대문자. "컬럼"는 소문자.로 구분해서 쓰는 것이 가독성에 좋다.

-- Q. 일별 평균 운행횟수?
-- 일별 : DATE(rent_at)
-- 평균 : AVG
-- 운행횟수 : COUNT(*)

SELECT AVG(trip_count) AS trip_count_avg -- 일별로 평균적으로 1274개 운행이 되더라.
FROM ( -- {일별 운행횟수} -- 바구니
  SELECT 
    date(rent_at) AS rent_date, -- 1 첫번째 컬럼(열)
    COUNT(*) as trip_count -- 2 두번째 컬럼(열) - 집계된ㄱ밧
  FROM rental_history AS rh -- 약어
  GROUP BY 1 -- 인덱싱
)


-- -- {일별 운행횟수} 바구니
-- <평균의 평균>
-- *10개의 반의 평균키의 평균값을. -- 168
-- 1반(30명)의 평균키값이 170
-- 2반의 평균키가 165
-- ..
-- 10반의 평균키가 180
-- ---

-- Q. 정류소타입(type)별 정류소 갯수는?
SELECT 
    type, -- 정류소타입
    COUNT(station_id) AS station_count -- "정류소갯수"
FROM station 
GROUP BY 
    type -- 명시적으로 SELECT와 셋트쓰기
****

-- Q. 정류소 최근 갱신 일자(updated_at)별 정류소 갯수는?
SELECT 
  updated_at,
  COUNT(station_id) -- 정류소갯수
FROM station
GROUP BY 
  updated_at


-- Q. 정류소 최근 갱신 일자(updated_at)의 최소, 최대 값은?
SELECT 
  MIN(updated_at) AS min_updated_at, -- 최초날짜 2015-09-06
  MAX(updated_at) AS max_updated_at -- 최근날짜 2021-01-26
FROM station
-- 어떤것을 쪼개고, ~별 집계값을 구한게 아니기 때문에 GROUP BY를 쓰지 않습니다.


# SQL 구문 순서
<!-- https://cloud.google.com/bigquery/docs/reference/standard-sql/query-syntax?hl=ko -->
select:
    SELECT
        [ { ALL | DISTINCT } ]
        [ AS { STRUCT | VALUE } ]
        select_list
    [ FROM from_clause[, ...] ]
    [ WHERE bool_expression ] 
    [ GROUP BY { expression [, ...] | ROLLUP ( expression [, ...] ) } ]
    [ HAVING bool_expression ]
    [ ORDER BY expression [{ ASC | DESC }] [, ...] ]
    [ LIMIT count [ OFFSET skip_rows ] ]


# 과제
- 1) 프로그래머스 SUM,MAX,MIN 파트 풀기. https://school.programmers.co.kr/learn/courses/30/parts/17043
- 2) 프로그래머스 GROUP BY 파트 풀기. https://school.programmers.co.kr/learn/courses/30/parts/17044