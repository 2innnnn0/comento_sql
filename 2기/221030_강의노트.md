# 과제피드백.

# 1. 주문량이 많은 아이스크림들 조회하기
- 7월 아이스크림 총 주문량과 상반기의 아이스크림 총 주문량을 더한 값이 큰 순서대로 상위 3개의 맛을 조회하는 SQL 문을 작성해주세요.
- (주의) 7월에는 아이스크림 주문량이 많아 같은 아이스크림에 대하여 서로 다른 두 공장에서 아이스크림 가게로 출하를 진행하는 경우가 있습니다. 이 경우 같은 맛의 아이스크림이라도 다른 출하 번호를 갖게 됩니다.
- JULY테이블의 FLAVOR는 FIRST_HALF 테이블의 FLAVOR의 외래 키

```sql
SELECT FLAVOR
FROM
(
    SELECT
        FH.FLAVOR,
        SUM(FH.TOTAL_ORDER + J.TOTAL_ORDER) AS TOTAL_ORDER
    FROM FIRST_HALF FH -- 1. 1~6 아이스크림.
        JOIN JULY J -- 2. 7월. 
            ON FH.FLAVOR = J.FLAVOR -- 연결고리 (VLOOKUP key)
    GROUP BY 1
) t
ORDER BY TOTAL_ORDER DESC
LIMIT 3 -- 상위 3개의 맛을
```**
**
# 2. 그룹별 조건에 맞는 식당 목록 출력하기
```sql
# MEMBER_PROFILE와 REST_REVIEW 테이블에서 리뷰를 가장 많이 작성한 회원의 리뷰들을 조회하는 SQL문을 작성해주세요. 회원 이름, 리뷰 텍스트, 리뷰 작성일이 출력되도록 작성해주시고, 결과는 리뷰 작성일을 기준으로 오름차순, 리뷰 작성일이 같다면 리뷰 텍스트를 기준으로 오름차순 정렬해주세요.

# 1. 리뷰를 가장 많이 작성한 회원의 리뷰들 -> 회원별 리뷰의 갯수를 알아야 함. -> 많이 쓴 사람을 고르기.

WITH review_best_t AS (
    SELECT MEMBER_ID
    FROM 
    (
        SELECT
            MEMBER_ID,
            COUNT(REVIEW_ID) AS REVIEW_COUNT
        FROM REST_REVIEW
        GROUP BY
            MEMBER_ID
        ORDER BY
            2 DESC
        LIMIT 1
    ) AS t1 -- Every derived table must have its own alias (Mysql에서는 ALIAS를 지정해줘야 오류가 안남.)
)

# 2. 회원 이름, 리뷰 텍스트, 리뷰 작성일
SELECT 
    MP.MEMBER_NAME,
    RR.REVIEW_TEXT,
    DATE_FORMAT(RR.REVIEW_DATE, '%Y-%m-%d') AS REVIEW_DATE -- 2) REVIEW_DATE의 데이트 포맷이 예시와 동일해야 정답처리 됩니다.
FROM REST_REVIEW RR -- 1. 리뷰 테이블
    JOIN MEMBER_PROFILE MP -- 2. 유저 테이블
        ON RR.MEMBER_ID = MP.MEMBER_ID
WHERE RR.MEMBER_ID IN (SELECT MEMBER_ID FROM review_best_t)   -- 1) 동적dynamic으로 적용될 수 있도록 변경해줘야 함.

ORDER BY 
    REVIEW_DATE ASC, # 리뷰 작성일을 기준으로 오름차순,
    REVIEW_TEXT ASC # 리뷰 작성일이 같다면 리뷰 텍스트를 기준으로 오름차순

-- 2022-03-15 00:00:00 -> 2022-03-15
-- (일반적인 인지하는 포맷) YYYY-MM-DD HH:mm:ss
-- (SQL 문법 포맷) %Y-%m-%d

-- DATE FORMAT형식 -> 표준.
-- 연도 : YYYY
-- 월 : MM
-- 일 : DD
-- 2022-10-30 : YYYY-MM-DD
-- 10/30/2022 : MM/DD/YYYY
```

# 3. 5월 식품들의 총매출 조회하기
```sql
-- 코드를 입력하세요
# FOOD_PRODUCT와 FOOD_ORDER 테이블에서 생산일자가 2022년 5월인 식품들의 식품 ID, 식품 이름, 총매출을 조회하는 SQL문을 작성해주세요. 이때 결과는 총매출을 기준으로 내림차순 정렬해주시고 총매출이 같다면 식품 ID를 기준으로 오름차순 정렬해주세요.

SELECT # 식품 ID, 식품 이름, 총매출
    FO.PRODUCT_ID,
    FP.PRODUCT_NAME,
    SUM(FP.PRICE * FO.AMOUNT) AS TOTAL_SALES -- 총매출 : 가격*판매량
FROM # FOOD_PRODUCT와 FOOD_ORDER 
    FOOD_ORDER FO -- 주문
    JOIN FOOD_PRODUCT FP -- 상품(메타정보)
        ON FO.PRODUCT_ID = FP.PRODUCT_ID
WHERE 
    DATE_FORMAT(FO.PRODUCE_DATE, '%Y-%m') = '2022-05' # "생산일자가 2022년 5월인 식품"
GROUP BY 
    FO.PRODUCT_ID,
    FP.PRODUCT_NAME
ORDER BY
    TOTAL_SALES DESC, # 1. 총매출을 기준으로 내림차순 정렬해주시고 
    FO.PRODUCT_ID ASC # 2. 총매출이 같다면 식품 ID를 기준으로 오름차순 정렬해주세요.
```

# 4. 없어진 기록 찾기
```sql
# 천재지변으로 인해 일부 데이터가 유실되었습니다.
# 입양을 간 기록은 있는데, 보호소에 들어온 기록이 없는 동물의 ID와 이름을 ID 순으로 조회하는 SQL문을 작성해주세요.

SELECT 
    OUTS.ANIMAL_ID AS out_animal_id, -- 나간 동물ID
    OUTS.NAME
FROM ANIMAL_OUTS OUTS -- 있고.(얘가 큰 상황)
    LEFT JOIN ANIMAL_INS INS -- 데이터가 일부 없음.
        ON OUTS.ANIMAL_ID = INS.ANIMAL_ID
WHERE INS.ANIMAL_ID IS NULL -- 들어온 동물ID 값이 없는 경우.

# # 같은 결과. RIGHT 조인으로 표현
# SELECT 
#     OUTS.ANIMAL_ID,
#     OUTS.NAME
# FROM ANIMAL_INS INS
#     RIGHT JOIN ANIMAL_OUTS OUTS
#         ON INS.ANIMAL_ID = OUTS.ANIMAL_ID
# WHERE INS.ANIMAL_ID IS NULL
```

# 5. 있었는데요 없었습니다
```sql
# 관리자의 실수로 일부 동물의 입양일이 잘못 입력되었습니다. 
# 보호 시작일보다 입양일이 더 빠른 동물의 아이디와 이름을 조회하는 SQL문을 작성해주세요. 
# 이때 결과는 보호 시작일이 빠른 순으로 조회해야합니다.
# 조건 : 보호시작일 <= 입양일. 이 케이스가 아닌 경우가 발생.

-- 코드를 입력하세요
SELECT 
    I.ANIMAL_ID, 
    I.NAME
FROM ANIMAL_INS I #(큰덩어리) 보호시작일
    JOIN ANIMAL_OUTS O #(작은덩어리) 입양일
        ON I.ANIMAL_ID = O.ANIMAL_ID # 연결고리
WHERE I.DATETIME > O.DATETIME  # 보호시작일 > 입양일 (예외케이스)
ORDER BY I.DATETIME , O.DATETIME
```


# 6. 오랜 기간 보호한 동물(1)
```sql
# 조건WHERE : 아직 입양을 못 간 동물(OUT이 없다) 중, "가장 오래 보호소"(MIN_DATETIME)에 있었던 
# 조회SELECT : "동물 3마리의 이름NAME"과 "보호 시작일INS.DATETIME"을 조회하는 SQL문을 작성해주세요.
# 순서ORDER : 이때 결과는 "보호 시작일"(INS.DATETIME ASC) 순으로 조회해야 합니다.
-- 코드를 입력하세요
SELECT 
    # I.ANIMAL_ID, -- 고유한ID값.(UNIQUE)
    I.NAME, -- 중복이 가능.(jane, jane, jane.. 중복 되는 케이스.)
    I.DATETIME -- 가장 오래된 애들을 알 수 있는 정보.(가장 작은 값들만 뽑아야함.)
FROM ANIMAL_INS I -- (큰덩어리) 1.보호소들어온애들 
    LEFT JOIN ANIMAL_OUTS O -- (작은덩어리) 2.입양간애들
        ON I.ANIMAL_ID = O.ANIMAL_ID -- 1,2의 연결고리.
WHERE O.ANIMAL_ID IS NULL -- 입양을 못 간 동물(1번에있는데, 2번에는없는애)
ORDER BY I.DATETIME ASC -- 보호시작일 순.
LIMIT 3
```

# 7. 보호소에서 중성화한 동물
```sql
# 보호소에서 중성화 수술을 거친 동물 정보를 알아보려 합니다. 
# 보호소에 "들어올" 당시에는 중성화 되지 않았지만, 
# 보호소를 "나갈" 당시에는 중성화된 
# 동물의 아이디와 생물 종, 이름을 조회하는 아이디 순으로 조회하는 SQL 문을 작성해주세요.
SELECT 
    I.ANIMAL_ID,
    I.ANIMAL_TYPE,
    I.NAME
FROM ANIMAL_INS I -- (큰덩어리) 1. 보호소 들어온.
    LEFT JOIN ANIMAL_OUTS O -- (작은덩어리) 2. 보호소 나간.
        ON I.ANIMAL_ID = O.ANIMAL_ID
WHERE (I.SEX_UPON_INTAKE NOT IN ('Spayed Female', 'Neutered Male') -- 보호소에 "들어올" 당시에는 중성화 되지 않았지만, 
        AND O.SEX_UPON_OUTCOME IN ('Spayed Female', 'Neutered Male'))-- 보호소를 "나갈" 당시에는 중성화된 
ORDER BY I.ANIMAL_ID -- 아이디 순으로 조회하는
```

# 8. 상품 별 오프라인 매출 구하기
```sql
-- 코드를 입력하세요
# PRODUCT 테이블과 OFFLINE_SALE 테이블에서 상품코드 별 매출액(판매가 * 판매량) 합계를 출력하는 SQL문을 작성해주세요. 결과는 매출액을 기준으로 내림차순 정렬해주시고 매출액이 같다면 상품코드를 기준으로 오름차순 정렬해주세요.

SELECT 
    -- 상품코드 별 매출액(판매가 * 판매량) 합계
    P.PRODUCT_CODE,
    SUM(P.PRICE * OS.SALES_AMOUNT) AS SALES
FROM OFFLINE_SALE OS
    JOIN PRODUCT P
        ON OS.PRODUCT_ID = P.PRODUCT_ID
GROUP BY 1
ORDER BY 
    SALES DESC,
    PRODUCT_CODE ASC
# 결과는 매출액을 기준으로 내림차순 정렬해주시고 
# 매출액이 같다면 상품코드를 기준으로 오름차순 정렬해주세요.
```

# 9. 상품을 구매한 회원 비율 구하기
```sql
-- 코드를 입력하세요
# USER_INFO 테이블과 ONLINE_SALE 테이블에서 
# e.g. 100명이 가입했는데, 50명이 구매를 했음 -> 50/100 = 50%
# 2021년에 가입한 전체 회원들 중 상품을 구매한 회원수와 상품을 구매한 회원의 비율(=2021년에 가입한 회원 중 상품을 구매한 회원수 / 2021년에 가입한 전체 회원 수)을 년, 월 별로 출력하는 SQL문을 작성해주세요. 상품을 구매한 회원의 비율은 소수점 두번째자리에서 반올림하고, 전체 결과는 년을 기준으로 오름차순 정렬해주시고 년이 같다면 월을 기준으로 오름차순 정렬해주세요.

WITH total_joined_t AS ( # 2021년에 가입한 전체 회원
SELECT 
    # COUNT(DISTINCT USER_ID) AS TOTAL_USERS -- 158
    USER_ID,
    COUNT(USER_ID) OVER() AS TOTAL_USERS
FROM USER_INFO UI -- 전체 유저 정보.
WHERE 1=1
AND EXTRACT(YEAR FROM UI.JOINED) = 2021 -- 2021년에 가입한 전체 회원
)

SELECT
    # 년, 월 별로
    # 상품을 구매한 회원수와 상품을 구매한 회원의 비율(=2021년에 가입한 회원 중 상품을 구매한 회원수 / 2021년에 가입한 전체 회원 수)
   EXTRACT(YEAR FROM OS.SALES_DATE) AS YEAR, -- OS.SALES_DATE
   EXTRACT(MONTH FROM OS.SALES_DATE) AS MONTH,
   COUNT(DISTINCT OS.USER_ID) AS PUCHASED_USERS,
   ROUND(COUNT(DISTINCT OS.USER_ID) / MAX(UI.TOTAL_USERS),1) AS PUCHASED_RATIO -- 상품을 구매한 회원의 비율은 소수점 두번째자리에서 반올림하고, 
FROM total_joined_t UI -- USER_INFO UI -- 전체 유저 정보.
    LEFT JOIN ONLINE_SALE OS -- 구매한 유저 정보.
        ON UI.USER_ID = OS.USER_ID
WHERE 1=1
AND EXTRACT(YEAR FROM OS.SALES_DATE) IS NOT NULL
GROUP BY 1,2
ORDER BY 
    YEAR ASC,
    MONTH ASC
 # 전체 결과는 년을 기준으로 오름차순 정렬해주시고 
 # 년이 같다면 월을 기준으로 오름차순
```


# UNION ALL
- 데이터유형과 컬럼명이 동일한 두 개의 테이블을 수직으로 더하는 함수.
- e.g. 상반기 아이스크림 판매테이블이 있고, 7월 아이스크림 판매테이블 있을때. 상반기 테이블과 7월 테이블을 이어 붙일 수 있음.
- https://school.programmers.co.kr/learn/courses/30/lessons/133027 
```sql
SELECT FLAVOR, TOTAL_ORDER FROM JULY
UNION ALL
SELECT FLAVOR, TOTAL_ORDER FROM FIRST_HALF
```

# 날짜 포맷format
- 날짜를 표기하는 방법을 다르게 할 수 있다. 필요에 따라 날짜를 변경하는 과정이 요구 됨.
2022-08-07 (년-월-일)
07/08/2022 (일-월-년)

'2022-08-07' -> 날짜라는 것을 알려줘야함.
TYPE('2022-08-07') -> string(문자)

YYYY-MM-DD
strftime('%Y-%m-%d', '2022-10-01')
%Y = 2022
%m = 10
%d = 1
---
strftime('%Y%m%d', '20221001')
%Y = 2022
%m = 10
%d = 1

### Q. 날짜에서 요일(월~일). 주차(월의 주차[1-6], 1년의 주차[0-53]) 포맷팅
'2022-08-07' -> 요일, 주차 캘린더를 보면 알 수 있음.
%w	:	요일 day of week 0-6 with Sunday==0
strftime('%w', '2022-10-01')



# FUNCTIONS
## 1. 변환함수
```sql
SELECT 
  -- 1. 문자에서 날짜로 변환하는 방법.
  CURRENT_DATE(), -- 현재 날짜값 
  '2022-10-30', -- 문자 
  DATE('2022-10-30'), -- 날짜변환 방식1
  CAST('2022-10-30' AS DATE), -- 날짜변환 방식2
  -- 2. 숫자 <-> 문자
  1,
  CAST(1 AS STRING), -- 숫자를 문자로 변환.
  CAST('1' AS INT64), -- 문자를 숫자로 변환.
  CAST(CAST(1 AS STRING) AS INT64),
  CAST(CAST(CAST(CAST(CAST(CAST(1 AS STRING) AS INT64) AS STRING) AS INT64) AS STRING) AS INT64), -- 중첩도 가능
```

## 2. 날짜함수
```sql
-- 타임존에 대한 좀더 자세한 설명은 위키백과를 참조. https://ko.wikipedia.org/wiki/%EC%8B%9C%EA%B0%84%EB%8C%80
SELECT
  CURRENT_DATETIME(), -- 표준시UTC 기준. 2022-10-30T12:58:03.130405 (+00:00)
  CURRENT_DATETIME('Asia/Seoul'), -- 한국 서울의 타임존을 설정. 2022-10-30T21:58:26.228276 (+09:00)
  CURRENT_DATETIME('Asia/Tokyo'), -- 일본 도쿄의 타임존은 동일하다. 2022-10-30T21
  TIMESTAMP_SECONDS(1666666666) -- UNIXTIME(1970-01-01을 기준으로 경과된 초seconds) 2022-10-25 02:57:46 UTC
```

## 3. 수학함수

## 4. 문자함수

```sql
SELECT
  LOWER("The bLuE HouSe"), -- the blue house
  UPPER("The bLuE HouSe") -- THE BLUE HOUSE
```


# 코호트 차트
- 코호트Cohort : 같은 특징을 가진 유저들을 그룹핑해서 현상을 추적하는 기법.
- 가령, 프로모션을 받고 가입한 유저그룹과 그렇지 않은 유저 그룹을 비교해서 프로모션의 효과를 검증할 수 있다.
- 추가로 프로모션을 받은 유저들이 계속 잔존하는지 리텐션 그래프를 그릴 수 있다.
- 이때 우리가 WINDOW_FUNCTION을 사용하면 코호트를 구할 수 있다.

# **WINDOW_FUNCTION**
-- https://cloud.google.com/bigquery/docs/reference/standard-sql/window-function-calls?hl=ko#common_tables_used_in_examples

## 예시1 PRODUCE 테이블
+-------------------------------------+ "OUTPUT"
| item      | category   | purchases  | purchases %  | total_purchases
+-------------------------------------+
| kale      | vegetable  | 23         | 23/54        | 54
| banana    | fruit      | 2          | 2/54         | 54
| cabbage   | vegetable  | 9          | 9/54         | 54
| apple     | fruit      | 8          | 8/54         | 54
| leek      | vegetable  | 2          | 2/54         | 54
| lettuce   | vegetable  | 10         | 10/54        | 54
+-------------------------------------+
- 여기서 각 item별 구매비중을 구하고 싶다면..? WINDOW_FUNCTION 을 사용하면 구할 수 있다.

-- 1. 기존 집계.
```sql
SELECT
    SUM(purchases) -- '54'라는 하나의 행(값)으로 떨어짐. 집계이기 때문에 기존 행들과 같이 쓸 수 없음.
FROM PRODUCE
```

-- 2. 윈도우 계산 --  dynamic
```sql
SELECT 
    item, purchases, category, 
    SUM(purchases) OVER () AS total_purchases -- 기존 행들을 그대로 살릴 수 있으면서, 불러올 수 있음. 집계가 아니므로 GROUP BY를 쓰지 않음.
FROM Produce
```


## 예시2 rental_history 테이블(따릉이)
-- Q. 101번째 정류소의 각 대여건별로 최초 대여건으로부터 경과일을 구하라.
e.g. 
+-------------------------------------+
| rent_at    | min_rent_at | day_diff  | 
+-------------------------------------+
| 2015-09-19 | 2015-09-19  | 0        |
| 2015-09-25 | 2015-09-19  | 6        |
| 2015-09-30 | 2015-09-19  | 16       |
+-------------------------------------+


```sql
SELECT 
  rent_at,
  MIN(rent_at) OVER() AS min_rent_at, -- 최초 대여건 날짜.
  DATE_DIFF(rent_at, MIN(rent_at) OVER(), DAY) AS day_diff
FROM rental_history
WHERE rent_station_id= 101
ORDER BY 
  rent_at
```

## 예시3. 최초 대여로부터 5번째 대여건의 rent_at을 추출하라.
```sql
SELECT 
  rent_at,
  ROW_NUMBER() OVER(ORDER BY rent_at) AS rent_sequence -- 넘버링. rent_at 순서대로 번호를 붙일래.
FROM rental_history
WHERE rent_station_id= 101
ORDER BY 
  rent_at
```

# ROW_NUMBER() -- 1. 행번호 부여하는 개념.
-- 2. 어떻게 행번호를 부여할지를 정하는 부분.
OVER(PARTITION BY r.rent_station_id -- 2.1 PARTITION BY | 파티션 친다("구분"짓는) -> 대여정류소별로 구분을 짓는
    ORDER BY r.rent_at DESC)  -- 2.2 ORDER BY | 정렬(순서) -> 대여시각이 가장 큰 것부터 내림차순으로 행번호를 붙인다
