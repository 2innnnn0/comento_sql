# 과제피드백.

# Q1. 정류소별로 가장 마지막에 빌려진 자전거의 대여시각을 구하는 쿼리를 작성.
```sql
--  Q1. 정류소별로 가장 마지막에 빌려진 자전거의 대여시각 을 구하는 쿼리를 작성.
WITH result_t AS (
SELECT 
  r.rent_station_id,
  r.rent_at,
  ROW_NUMBER() OVER(PARTITION BY r.rent_station_id ORDER BY r.rent_at DESC) AS rn
FROM rental_history r 
)

SELECT *
FROM result_t
WHERE rn = 1 -- 가장 마지막에 빌렸을때의 대여시각.
```



-- 정류소번호 | (자전거번호) | 자전거대여시각. | RANK(가장마지막에 빌려진 것 부터 순서)
-- 101 | 111 | 2021-01-30 | 1
-- 101 | 121 | 2021-01-29 | 2
-- 101 | 121 | 2021-01-21 | 3
-- 101 | 121 | 2021-01-01 | 4

-- OUTPUT
-- 101 | 2021-01-30


-- WINDOW
-- -- ROW_NUMBER() OVER()

SELECT 
  *
FROM
(
  SELECT
    DISTINCT -- 중복을 제거
    rent_station_id,
    -- bike_id,
    -- rent_at,
    -- distance, -- 주행거리
    -- 대여건이 생길때마다 주행거리가 누적으로 표현되는 값을 구해보려고 합니다.
    
    -- 정류소에서 
    
    
    MAX(distance) OVER(PARTITION BY rent_station_id) AS "가장긴주행거리", -- 한번 주행으로 218km..?
    MIN(distance) OVER(PARTITION BY rent_station_id) AS "가장짧은주행거리"
    
    SUM(distance) OVER(PARTITION BY rent_station_id) AS "총누적주행거리",  -- "어떠한 구분"도 없는 상태.
    SUM(distance) OVER(PARTITION BY rent_station_id ORDER BY rent_at) AS "누적주행거리",
    SUM(distance) OVER(PARTITION BY rent_station_id ORDER BY rent_at) / SUM(distance) OVER(PARTITION BY rent_station_id) * 100 AS "누적비율%"
    -- 누적 비율% -> "정류소에서 전체 누적거리의 80%수준까지 도달한 대여건이 뭐야..?"
  
    -- 랭킹 
    -- ROW_NUMBER() OVER(PARTITION BY rent_station_id ORDER BY rent_at) AS ranking_desc,
  FROM rental_history
  WHERE 1=1
  -- AND rent_station_id IN (101) -- ,102)
  ORDER BY rent_at 
  LIMIT 4999
)
ORDER BY "가장긴주행거리" DESC
-- WHERE "누적비율%" > 80 -- 2019-09-21 21:58:11 부터 나오겠다.

-- -- 각 정류소별로 가장마지ㅏㄱ 대여.
-- 101 1 "2021-01-31"
-- 102 1 "2021-02-15"
-- 103   "2021-03-20"
-- ..


-- (ASIS)정류소의 "구분"을 안하는 상태. 정류소의 구분없이 rent_at의 큰순서대로 번호가 매겨지는 것
      -- ROW_NUMBER() OVER(ORDER BY rent_at DESC)
    -- (TOBE)정류소별 rent_at이 큰순서대로 번호가 매겨짐.
      -- ROW_NUMBER() OVER(PARTITION BY rent_station_id ORDER BY rent_at DESC)
    
    -- 행의 번호를 붙일건데 어떤 조건이냐면
      -- 정류소별로 rent_at이 큰것(내림차순)부터 번호를 매길거야 -> ranking_desc=2 마지막에서 두번째로 빌려진 대여건 
-- ROW_NUMBER() OVER(PARTITION BY rent_station_id ORDER BY rent_at) AS ranking_desc,




# Q2. “요일별” 대여횟수를 구하는 쿼리를 구해주세요. 요일 은 월,화,수,목,금,토,일 같이 한글로 표현해주세요. 
```sql
-- Q2. “요일별” 대여횟수를 구하는 쿼리를 구해주세요. 
-- 요일 은 월,화,수,목,금,토,일 같이 한글로 표현해주세요.

WITH result_t as (
SELECT 
  st.name AS station_name,
  rh.rent_at -- 2015-09-01(월), 2015-09-02(화), 2015-09-06(금), .........
FROM rental_history rh -- 대여이력
  JOIN station st
    ON rh.rent_station_id = st.station_id
)
  
-- 요일을 구하는 함수 : https://www.sqlite.org/lang_datefunc.html
SELECT
  CASE
    WHEN strftime('%w',rent_at) = '0' then "0일"
    WHEN strftime('%w',rent_at) = '1' then "1월"
    WHEN strftime('%w',rent_at) = '2' then "2화"
    WHEN strftime('%w',rent_at) = '3' then "3수"
    WHEN strftime('%w',rent_at) = '4' then "4목" 
    WHEN strftime('%w',rent_at) = '5' then "5금"
    WHEN strftime('%w',rent_at) = '6' then "6토"
  END AS day,
  COUNT(*) AS rent_count
FROM result_t
GROUP BY day -- 또는 1
ORDER BY day 
```

# 문제를 풀어봅시다.
- https://solvesql.com/playground/ 접속
- 우측에 "따릉이 자전거 이용 현황"을 누른 후 코드를 입력하세요.

- 문제를 잘푸는 꿀팁. "상상력"을 발휘합시다.
  - 1. 데이터를 먼저 살펴보기
    - 내가 구할 "테이블"의 구조를 이해하고 머릿속에 그려내기.
  - 2. 문제를 단계별로 쪼개는 연습. 
    - FROM / SELECT / WHERE에 각각에 들어가는 순서를 각각 적어보기.
  - 3. 한가지의 예시를 먼저 살펴보기.
    - 정류소 한곳만, 유저 한명만 먼저 살펴보기.
  - 4. 이제 전체로 확장해보기
    - 전체 정류소, 유저 전체.
  - 5. 코드를 가독성 있게 정리하기.
    - 나중에 다시 뽑아볼 경우, 혹은 데이터를 올바르게 추출했는지 리뷰를 받을 경우를 대비.


(SELECT)
## Q. 정류소 101의 위경도(lat, lng) 데이터를 추출하세요.
## Q. 정류소 테이블에서 이름에 '아파트'가 들어간 곳을 추출하세요.
(힌트 : LIKE '%{검색단어}%')
## Q. 주행거리가 50000m 이상인 대여건만 추출하세요.

(GROUP BY)
## Q. 정류소 101의 총대여건수, 총주행거리를 구하세요.
## Q. 정류소 101의 자전거별 대여건수를 구하세요. 이때 대여건수 내림차순으로 정렬해주세요.****
## Q. 정류소 101의 대여날짜별 대여건수를 구하세요. 이때, 대여날짜별 내림차순으로 정렬해주세요. (날짜형태는 2022-01-01) 
(힌트 : DATE(rent_at))
# Q. 대여날짜의 "요일"별 대여건수와 총주행거리를 구해주세요.
(힌트 : 요일을 구하는 함수 : https://www.sqlite.org/lang_datefunc.html
WHEN strftime('%w',rent_at) = '0' THEN "일")
# Q. 대여날짜의 "시간대"별 대여건수와 총주행거리를 구해주세요.
(힌트 : strftime('%H', rent_at) AS "시간대별",)
## Q. local별 정류소 갯수를 구하세요.
## Q. local별 정류소 갯수와 대여건수와 주행거리합을 구하세요.

(JOIN)
## Q. 정류소 101의 반납정류소 이름과 위경도를 추출해주세요.
## Q. 정류소 101의 반납정류소별 총대여건수, 총주행거리를 구하세요. 이때 반납정류소의 이름도 같이 넣어주세요.














# 3. 5월 식품들의 총매출 조회하기
```sql
-- 코드를 입력하세요
# FOOD_PRODUCT와 FOOD_ORDER 테이블에서 생산일자가 2022년 5월인 식품들의 식품 ID, 식품 이름, 총매출을 조회하는 SQL문을 작성해주세요. 이때 결과는 총매출을 기준으로 내림차순 정렬해주시고 총매출이 같다면 식품 ID를 기준으로 오름차순 정렬해주세요.

SELECT # 식품 ID, 식품 이름, 총매출
    FO.PRODUCT_ID,
    FP.PRODUCT_NAME,
    SUM(FP.PRICE * FO.AMOUNT) AS TOTAL_SALES -- 총매출 : 가격*판매량
FROM # FOOD_PRODUCT와 FOOD_ORDER 
    FOOD_ORDER FO -- 주문
    JOIN FOOD_PRODUCT FP -- 상품(메타정보)
        ON FO.PRODUCT_ID = FP.PRODUCT_ID
WHERE 
    DATE_FORMAT(FO.PRODUCE_DATE, '%Y-%m') = '2022-05' # "생산일자가 2022년 5월인 식품"
GROUP BY 
    FO.PRODUCT_ID,
    FP.PRODUCT_NAME
ORDER BY
    TOTAL_SALES DESC, # 1. 총매출을 기준으로 내림차순 정렬해주시고 
    FO.PRODUCT_ID ASC # 2. 총매출이 같다면 식품 ID를 기준으로 오름차순 정렬해주세요.
```

# 4. 없어진 기록 찾기
```sql
# 천재지변으로 인해 일부 데이터가 유실되었습니다.
# 입양을 간 기록은 있는데, 보호소에 들어온 기록이 없는 동물의 ID와 이름을 ID 순으로 조회하는 SQL문을 작성해주세요.

SELECT 
    OUTS.ANIMAL_ID AS out_animal_id, -- 나간 동물ID
    OUTS.NAME
FROM ANIMAL_OUTS OUTS -- 있고.(얘가 큰 상황)
    LEFT JOIN ANIMAL_INS INS -- 데이터가 일부 없음.
        ON OUTS.ANIMAL_ID = INS.ANIMAL_ID
WHERE INS.ANIMAL_ID IS NULL -- 들어온 동물ID 값이 없는 경우.

# # 같은 결과. RIGHT 조인으로 표현
# SELECT 
#     OUTS.ANIMAL_ID,
#     OUTS.NAME
# FROM ANIMAL_INS INS
#     RIGHT JOIN ANIMAL_OUTS OUTS
#         ON INS.ANIMAL_ID = OUTS.ANIMAL_ID
# WHERE INS.ANIMAL_ID IS NULL
```

# 5. 있었는데요 없었습니다
```sql
# 관리자의 실수로 일부 동물의 입양일이 잘못 입력되었습니다. 
# 보호 시작일보다 입양일이 더 빠른 동물의 아이디와 이름을 조회하는 SQL문을 작성해주세요. 
# 이때 결과는 보호 시작일이 빠른 순으로 조회해야합니다.
# 조건 : 보호시작일 <= 입양일. 이 케이스가 아닌 경우가 발생.

-- 코드를 입력하세요
SELECT 
    I.ANIMAL_ID, 
    I.NAME
FROM ANIMAL_INS I #(큰덩어리) 보호시작일
    JOIN ANIMAL_OUTS O #(작은덩어리) 입양일
        ON I.ANIMAL_ID = O.ANIMAL_ID # 연결고리
WHERE I.DATETIME > O.DATETIME  # 보호시작일 > 입양일 (예외케이스)
ORDER BY I.DATETIME , O.DATETIME
```


# 6. 오랜 기간 보호한 동물(1)
```sql
# 조건WHERE : 아직 입양을 못 간 동물(OUT이 없다) 중, "가장 오래 보호소"(MIN_DATETIME)에 있었던 
# 조회SELECT : "동물 3마리의 이름NAME"과 "보호 시작일INS.DATETIME"을 조회하는 SQL문을 작성해주세요.
# 순서ORDER : 이때 결과는 "보호 시작일"(INS.DATETIME ASC) 순으로 조회해야 합니다.
-- 코드를 입력하세요
SELECT 
    # I.ANIMAL_ID, -- 고유한ID값.(UNIQUE)
    I.NAME, -- 중복이 가능.(jane, jane, jane.. 중복 되는 케이스.)
    I.DATETIME -- 가장 오래된 애들을 알 수 있는 정보.(가장 작은 값들만 뽑아야함.)
FROM ANIMAL_INS I -- (큰덩어리) 1.보호소들어온애들 
    LEFT JOIN ANIMAL_OUTS O -- (작은덩어리) 2.입양간애들
        ON I.ANIMAL_ID = O.ANIMAL_ID -- 1,2의 연결고리.
WHERE O.ANIMAL_ID IS NULL -- 입양을 못 간 동물(1번에있는데, 2번에는없는애)
ORDER BY I.DATETIME ASC -- 보호시작일 순.
LIMIT 3
```

# 7. 보호소에서 중성화한 동물
```sql
# 보호소에서 중성화 수술을 거친 동물 정보를 알아보려 합니다. 
# 보호소에 "들어올" 당시에는 중성화 되지 않았지만, 
# 보호소를 "나갈" 당시에는 중성화된 
# 동물의 아이디와 생물 종, 이름을 조회하는 아이디 순으로 조회하는 SQL 문을 작성해주세요.
SELECT 
    I.ANIMAL_ID,
    I.ANIMAL_TYPE,
    I.NAME
FROM ANIMAL_INS I -- (큰덩어리) 1. 보호소 들어온.
    LEFT JOIN ANIMAL_OUTS O -- (작은덩어리) 2. 보호소 나간.
        ON I.ANIMAL_ID = O.ANIMAL_ID
WHERE (I.SEX_UPON_INTAKE NOT IN ('Spayed Female', 'Neutered Male') -- 보호소에 "들어올" 당시에는 중성화 되지 않았지만, 
        AND O.SEX_UPON_OUTCOME IN ('Spayed Female', 'Neutered Male'))-- 보호소를 "나갈" 당시에는 중성화된 
ORDER BY I.ANIMAL_ID -- 아이디 순으로 조회하는
```

# 8. 상품 별 오프라인 매출 구하기
```sql
-- 코드를 입력하세요
# PRODUCT 테이블과 OFFLINE_SALE 테이블에서 상품코드 별 매출액(판매가 * 판매량) 합계를 출력하는 SQL문을 작성해주세요. 결과는 매출액을 기준으로 내림차순 정렬해주시고 매출액이 같다면 상품코드를 기준으로 오름차순 정렬해주세요.

SELECT 
    -- 상품코드 별 매출액(판매가 * 판매량) 합계
    P.PRODUCT_CODE,
    SUM(P.PRICE * OS.SALES_AMOUNT) AS SALES
FROM OFFLINE_SALE OS
    JOIN PRODUCT P
        ON OS.PRODUCT_ID = P.PRODUCT_ID
GROUP BY 1
ORDER BY 
    SALES DESC,
    PRODUCT_CODE ASC
# 결과는 매출액을 기준으로 내림차순 정렬해주시고 
# 매출액이 같다면 상품코드를 기준으로 오름차순 정렬해주세요.
```

# 9. 상품을 구매한 회원 비율 구하기
```sql
-- 코드를 입력하세요
# USER_INFO 테이블과 ONLINE_SALE 테이블에서 
# e.g. 100명이 가입했는데, 50명이 구매를 했음 -> 50/100 = 50%
# 2021년에 가입한 전체 회원들 중 상품을 구매한 회원수와 상품을 구매한 회원의 비율(=2021년에 가입한 회원 중 상품을 구매한 회원수 / 2021년에 가입한 전체 회원 수)을 년, 월 별로 출력하는 SQL문을 작성해주세요. 상품을 구매한 회원의 비율은 소수점 두번째자리에서 반올림하고, 전체 결과는 년을 기준으로 오름차순 정렬해주시고 년이 같다면 월을 기준으로 오름차순 정렬해주세요.

WITH total_joined_t AS ( # 2021년에 가입한 전체 회원
SELECT 
    # COUNT(DISTINCT USER_ID) AS TOTAL_USERS -- 158
    USER_ID,
    COUNT(USER_ID) OVER() AS TOTAL_USERS
FROM USER_INFO UI -- 전체 유저 정보.
WHERE 1=1
AND EXTRACT(YEAR FROM UI.JOINED) = 2021 -- 2021년에 가입한 전체 회원
)

SELECT
    # 년, 월 별로
    # 상품을 구매한 회원수와 상품을 구매한 회원의 비율(=2021년에 가입한 회원 중 상품을 구매한 회원수 / 2021년에 가입한 전체 회원 수)
   EXTRACT(YEAR FROM OS.SALES_DATE) AS YEAR, -- OS.SALES_DATE
   EXTRACT(MONTH FROM OS.SALES_DATE) AS MONTH,
   COUNT(DISTINCT OS.USER_ID) AS PUCHASED_USERS,
   ROUND(COUNT(DISTINCT OS.USER_ID) / MAX(UI.TOTAL_USERS),1) AS PUCHASED_RATIO -- 상품을 구매한 회원의 비율은 소수점 두번째자리에서 반올림하고, 
FROM total_joined_t UI -- USER_INFO UI -- 전체 유저 정보.
    LEFT JOIN ONLINE_SALE OS -- 구매한 유저 정보.
        ON UI.USER_ID = OS.USER_ID
WHERE 1=1
AND EXTRACT(YEAR FROM OS.SALES_DATE) IS NOT NULL
GROUP BY 1,2
ORDER BY 
    YEAR ASC,
    MONTH ASC
 # 전체 결과는 년을 기준으로 오름차순 정렬해주시고 
 # 년이 같다면 월을 기준으로 오름차순
```


# UNION ALL
- 데이터유형과 컬럼명이 동일한 두 개의 테이블을 수직으로 더하는 함수.
- e.g. 상반기 아이스크림 판매테이블이 있고, 7월 아이스크림 판매테이블 있을때. 상반기 테이블과 7월 테이블을 이어 붙일 수 있음.
- https://school.programmers.co.kr/learn/courses/30/lessons/133027 
```sql
SELECT FLAVOR, TOTAL_ORDER FROM JULY
UNION ALL
SELECT FLAVOR, TOTAL_ORDER FROM FIRST_HALF
```

# 날짜 포맷format
- 날짜를 표기하는 방법을 다르게 할 수 있다. 필요에 따라 날짜를 변경하는 과정이 요구 됨.
2022-08-07 (년-월-일)
07/08/2022 (일-월-년)

'2022-08-07' -> 날짜라는 것을 알려줘야함.
TYPE('2022-08-07') -> string(문자)

YYYY-MM-DD
strftime('%Y-%m-%d', '2022-10-01')
%Y = 2022
%m = 10
%d = 1
---
strftime('%Y%m%d', '20221001')
%Y = 2022
%m = 10
%d = 1

### Q. 날짜에서 요일(월~일). 주차(월의 주차[1-6], 1년의 주차[0-53]) 포맷팅
'2022-08-07' -> 요일, 주차 캘린더를 보면 알 수 있음.
%w	:	요일 day of week 0-6 with Sunday==0
strftime('%w', '2022-10-01')



# FUNCTIONS
## 1. 변환함수
```sql
SELECT 
  -- 1. 문자에서 날짜로 변환하는 방법.
  CURRENT_DATE(), -- 현재 날짜값 
  '2022-10-30', -- 문자 
  DATE('2022-10-30'), -- 날짜변환 방식1
  CAST('2022-10-30' AS DATE), -- 날짜변환 방식2
  -- 2. 숫자 <-> 문자
  1,
  CAST(1 AS STRING), -- 숫자를 문자로 변환.
  CAST('1' AS INT64), -- 문자를 숫자로 변환.
  CAST(CAST(1 AS STRING) AS INT64),
  CAST(CAST(CAST(CAST(CAST(CAST(1 AS STRING) AS INT64) AS STRING) AS INT64) AS STRING) AS INT64), -- 중첩도 가능
```

## 2. 날짜함수
```sql
-- 타임존에 대한 좀더 자세한 설명은 위키백과를 참조. https://ko.wikipedia.org/wiki/%EC%8B%9C%EA%B0%84%EB%8C%80
SELECT
  CURRENT_DATETIME(), -- 표준시UTC 기준. 2022-10-30T12:58:03.130405 (+00:00)
  CURRENT_DATETIME('Asia/Seoul'), -- 한국 서울의 타임존을 설정. 2022-10-30T21:58:26.228276 (+09:00)
  CURRENT_DATETIME('Asia/Tokyo'), -- 일본 도쿄의 타임존은 동일하다. 2022-10-30T21
  TIMESTAMP_SECONDS(1666666666) -- UNIXTIME(1970-01-01을 기준으로 경과된 초seconds) 2022-10-25 02:57:46 UTC
```

## 3. 수학함수

## 4. 문자함수

```sql
SELECT
  LOWER("The bLuE HouSe"), -- the blue house
  UPPER("The bLuE HouSe") -- THE BLUE HOUSE
```


# 코호트 차트
- 코호트Cohort : 같은 특징을 가진 유저들을 그룹핑해서 현상을 추적하는 기법.
- 가령, 프로모션을 받고 가입한 유저그룹과 그렇지 않은 유저 그룹을 비교해서 프로모션의 효과를 검증할 수 있다.
- 추가로 프로모션을 받은 유저들이 계속 잔존하는지 리텐션 그래프를 그릴 수 있다.
- 이때 우리가 WINDOW_FUNCTION을 사용하면 코호트를 구할 수 있다.

# **WINDOW_FUNCTION**
-- https://cloud.google.com/bigquery/docs/reference/standard-sql/window-function-calls?hl=ko#common_tables_used_in_examples

## 예시1 PRODUCE 테이블
+-------------------------------------+ "OUTPUT"
| item      | category   | purchases  | purchases %  | total_purchases
+-------------------------------------+
| kale      | vegetable  | 23         | 23/54        | 54
| banana    | fruit      | 2          | 2/54         | 54
| cabbage   | vegetable  | 9          | 9/54         | 54
| apple     | fruit      | 8          | 8/54         | 54
| leek      | vegetable  | 2          | 2/54         | 54
| lettuce   | vegetable  | 10         | 10/54        | 54
+-------------------------------------+
- 여기서 각 item별 구매비중을 구하고 싶다면..? WINDOW_FUNCTION 을 사용하면 구할 수 있다.

-- 1. 기존 집계.
```sql
SELECT
    SUM(purchases) -- '54'라는 하나의 행(값)으로 떨어짐. 집계이기 때문에 기존 행들과 같이 쓸 수 없음.
FROM PRODUCE
```

-- 2. 윈도우 계산 --  dynamic
```sql
SELECT 
    item, purchases, category, 
    SUM(purchases) OVER () AS total_purchases -- 기존 행들을 그대로 살릴 수 있으면서, 불러올 수 있음. 집계가 아니므로 GROUP BY를 쓰지 않음.
FROM Produce
```


## 예시2 rental_history 테이블(따릉이)
-- Q. 101번째 정류소의 각 대여건별로 최초 대여건으로부터 경과일을 구하라.
e.g. 
+-------------------------------------+
| rent_at    | min_rent_at | day_diff  | 
+-------------------------------------+
| 2015-09-19 | 2015-09-19  | 0        |
| 2015-09-25 | 2015-09-19  | 6        |
| 2015-09-30 | 2015-09-19  | 16       |
+-------------------------------------+


```sql
SELECT 
  rent_at,
  MIN(rent_at) OVER() AS min_rent_at, -- 최초 대여건 날짜.
  DATE_DIFF(rent_at, MIN(rent_at) OVER(), DAY) AS day_diff
FROM rental_history
WHERE rent_station_id= 101
ORDER BY 
  rent_at
```

## 예시3. 최초 대여로부터 5번째 대여건의 rent_at을 추출하라.
```sql
SELECT 
  rent_at,
  ROW_NUMBER() OVER(ORDER BY rent_at) AS rent_sequence -- 넘버링. rent_at 순서대로 번호를 붙일래.
FROM rental_history
WHERE rent_station_id= 101
ORDER BY 
  rent_at
```

# ROW_NUMBER() -- 1. 행번호 부여하는 개념.
-- 2. 어떻게 행번호를 부여할지를 정하는 부분.
OVER(PARTITION BY r.rent_station_id -- 2.1 PARTITION BY | 파티션 친다("구분"짓는) -> 대여정류소별로 구분을 짓는
    ORDER BY r.rent_at DESC)  -- 2.2 ORDER BY | 정렬(순서) -> 대여시각이 가장 큰 것부터 내림차순으로 행번호를 붙인다
